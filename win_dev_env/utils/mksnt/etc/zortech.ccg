# Generalized C/C++ interface for Zortech C++ 3.0.
#
# This file assumes that the Zortech compiler package has been correctly
# configured.  In particular, the following assumptions are made:
# - LIB points to Zortech C++ libraries.
# - INCLUDE points to Zortech C++ headers.
# - PATH includes the directory containing the Zortech binaries.
#
# You can search a different library directory with -L dirname

#ECHO = 1;			# see compiler/linker commands

# ZTC option prefixes: these are passed through to compiler

Copts = { "-2","-3","-4","-a","-A","-b","-C","-D","-e","-g",
	   "-I","-j","-J","-N","-O","-p","-P","-r","-R","-s","-S","-u",
	   "-v","-w","-W","-x" };

LibDir = getenv("LIB");

Model = "s";
coptions = " ";
val = 0;
alib = "";

Libs = {};
Srcs = {};
Objs = {};
Output = "";

for (i in ARGV)
do
	if (substr(i,1,2) == "-m")
		coptions |= i | " ";
		Model = substr(i,3,1);
	elif (i == "-c")
		compile_only = 1;
	elif (substr(i,-2) == ".c" || substr(i,-4) == ".cpp" ||
	      substr(i,-4) == ".asm")
		Srcs |= i;
		opath = filepath(i);	# get file name
		name = opath[length(opath)-1];
		Objs |= substr(name, 1, rindex(name,".")) | "obj";
	elif (substr(i,-4) == ".obj")
		Objs |= i | " ";
	elif (i == "-o")
		advance i;
		Output = i;
	elif (substr(i,1,2) == "-e")	# -e<output-file>
		Output = substr(i,3);
	elif (index(Copts, substr(i,1,2)) != 0)
		coptions |= i | " ";
	elif (i == "-M")		# linker map in output.map
		map = 1;
	elif (substr(i,1,2) == "-L")
		LibDir = replace(substr(i,3), "/", "\\");
	elif (i == "-l")
		advance i;
		alib = i;
	elif (substr(i,1,2) == "-l")
		alib = substr(i,3);
	elif (substr(i,-4) == ".lib")
		Libs |= i;
	elif (i == "-f")
		FloatLib = "emu";
	elif (i == "-f87" || i == "-fp")
		FloatLib = "fp87";
	elif (i == "-f-")
		FloatLib = "";
	elif (substr(i,1,1) == "-")
		println gettext("Unknown option:"), i,
			gettext("(ignored)");
	else
		println gettext("Unknown"), i,
			gettext("(ignored)");
	fi
	if (alib)
		if (substr(alib,-4) != ".lib")
			alib |= ".lib";
		fi
		if (length(filepath(alib)) < 2)		# has path?
			Libs |= alib;
		else
			Libs |= LibDir | alib;
		fi
		alib = "";
	fi
done

if (! Objs)
	print gettext("No source or object files!\n");
	exit 1;
fi

if (Output == "")
	Output = Objs[0];
	Mapfile = substr(Output, 1, rindex(Output,"."));
	Output = Mapfile | "exe";
	Mapfile |=  "map";
fi

# compile all source files
if (Srcs)
	line = "ztc -c"| coptions | Srcs;
	if (length(line) < 110)
		if (compile_only)
			ovl_exec line;
		else
			val = exec(line);
		fi
	else
		for (i in Srcs)
		do
			val = exec("ztc -c", coptions,  i);
			if (val)
				exit val;
			fi
		done
	fi
fi
if (compile_only || val)
	exit val;
fi

# run the linker

# Building a linker command is relatively trivial for blink
#if (FloatLib != "")
#	FloatLib = LibDir | "\\" | FloatLib | " " | LibDir | "\\math" | Model | " ";
#fi

temp = tempfile("lnk");
delete temp;

Output = replace(Output, "/", "\\");
Mapfile = replace(Mapfile, "/", "\\");

#print LibDir | "\\c0" | Model | ".obj" -> temp;		# C startup

for (i in Objs)						# object list
do
	print replace(i,"/","\\") | "+\n" -> temp;
done

print "\n" | Output | "\n" | Mapfile | "\n" -> temp;	# executable, mapfile

for (i in Libs)						# user libraries
do
	print replace(i, "/", "\\") | "+\n" -> temp;
done

print "/noi" -> temp;					# blink options
if (map)
	print "/m" -> temp;
fi
print "\n" -> temp;

close temp;

val = exec("blink @" | replace(temp,"/","\\"));
delete temp;
if (val == 127)
	println gettext("Could not find blink!");
fi
exit val;
